const rawToEntityEntries=[["&","&amp;"],["<","&lt;"],[">","&gt;"],['"',"&quot;"],["'","&#39;"]];Object.fromEntries([...rawToEntityEntries.map(([raw,entity])=>[entity,raw]),["&apos;","'"],["&nbsp;","Â "]]);const rawToEntity=new Map(rawToEntityEntries);const rawRe=new RegExp(`[${[...rawToEntity.keys()].join("")}]`,"g");function escape(str){return str.replaceAll(rawRe,m=>rawToEntity.get(m));}new WeakMap;class MacroOpeningTag{instance;constructor(instance){this.instance=instance;}}class ClosingTag{}class TemplateStringReturnValue{string;constructor(string){this.string=string;}}class RawString{value;constructor(value){this.value=value;}}class Block{name;content;constructor(name,content){this.name=name;this.content=content;}}const transform=(arg,internals)=>{if(arg instanceof MacroOpeningTag){internals.currentMacro=arg.instance;return internals.currentMacro.hasChildren?internals.currentMacro.enclosing.start:"";}if(arg instanceof Block){if(!internals.currentMacro){console.error("Cannot use block without opening macro");return"";}internals.currentMacro.blocks.set(arg.name,arg.content.string);return"";}if(arg instanceof ClosingTag){if(internals.currentMacro&&internals.currentMacro.hasChildren){return internals.currentMacro?.enclosing.end;}const blocks=internals.currentMacro.blocks;const template=internals.currentMacro.template;let macroString=template;blocks.forEach((value,key)=>{macroString=macroString.replace(`@__block:${key}`,value);});internals.currentMacro=null;return macroString;}if(arg instanceof TemplateStringReturnValue)return arg.string;if(typeof arg==="string")return escape(arg);if(arg instanceof RawString)return arg.value;if(Array.isArray(arg))return arg.join("");return arg;};const TemplateStringBuilder=(strings,...args)=>{const internals={currentMacro:null};let __final="";for(let index=0;index<strings.length;index++){const currentArg=args[index]??"";const transformedValue=transform(currentArg,internals);const currentString=strings[index]+transformedValue;__final+=currentString;}return new TemplateStringReturnValue(__final);};class Macro{templateFunction;props;template;renderString;enclosing;hasBlocks;hasChildren;blocks;helpers;constructor(templateFunction,props){this.templateFunction=templateFunction;this.props=props;this.renderString="";this.enclosing={start:"",end:""};this.hasBlocks=false;this.hasChildren=false;this.blocks=new Map;this.helpers={block:name=>{this.hasBlocks=true;return`@__block:${name}`;},children:()=>{this.hasChildren=true;return"@__children";}};this.template=this.templateFunction(this.helpers,this.props).string;}render(props){const instance=new Macro(this.templateFunction,props);return raw(instance.template);}open(props){const instance=this.props?this:new Macro(this.templateFunction,props);if(this.hasChildren){const splitted=instance.template.split("@__children");instance.enclosing.start=splitted.at(0);instance.enclosing.end=splitted.at(-1);}return new MacroOpeningTag(instance);}close(){return new ClosingTag;}html(strings,...args){const _strings=["",...strings,""];const _args=[this.open(),...args,this.close()];return TemplateStringBuilder(_strings,..._args);}with(props,callback){const instance=new Macro(this.templateFunction,props);return callback(instance);}}const macro=cb=>{return new Macro(cb,undefined);};const raw=str=>new RawString(str);const block=(name,content)=>new Block(name,content);const html=(strings,...args)=>{return TemplateStringBuilder(strings,...args);};export{TemplateStringReturnValue as TemplateStringReturnValue};export{macro as macro};export{raw as raw};export{block as block};export{html as html};